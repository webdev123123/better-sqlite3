class Backup : public node::ObjectWrap {
public:

	// Provides public access to the constructor.
	static v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate, v8::Local<v8::Object> database, v8::Local<v8::String> sourceDatabase, v8::Local<v8::String> destFile, v8::Local<v8::Int32> pages) {
		v8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, constructor);
		v8::Local<v8::Value> args[4] = { database, sourceDatabase, destFile, pages };
		constructing_privileges = true;
		v8::MaybeLocal<v8::Object> maybe_backup = c->NewInstance(OnlyContext, 4, args);
		constructing_privileges = false;
		return maybe_backup;
	}

	~Backup() {
		CloseHandles();
	}

private:

	explicit Backup(Database* _db, sqlite3* _dest_handle, sqlite3_backup* _backup_handle, int _pages) : node::ObjectWrap(),
		db(_db),
		dest_handle(_dest_handle),
		backup_handle(_backup_handle),
		pages(_pages),
		alive(true) {
		assert(db != NULL);
		assert(dest_handle != NULL);
		assert(backup_handle != NULL);
		assert(pages > 0);
	}

	REGISTER(Init) {
		v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(StringFromUtf8(isolate, "BackupOperation", -1));

		NODE_SET_PROTOTYPE_METHOD(t, "step", JS_step);

		constructor.Reset(isolate, t->GetFunction(OnlyContext).ToLocalChecked());
		constructing_privileges = false;
	}

	NODE_METHOD(JS_new) {
		if (!constructing_privileges) return ThrowTypeError("Disabled constructor");
		assert(info.IsConstructCall());
		REQUIRE_ARGUMENT_OBJECT(first, v8::Local<v8::Object> database);
		REQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> sourceDatabase);
		REQUIRE_ARGUMENT_STRING(third, v8::Local<v8::String> destFile);
		REQUIRE_ARGUMENT_INT32(fourth, int pages);
		Database* db = Unwrap<Database>(database);
		REQUIRE_DATABASE_OPEN(db->GetState());
		REQUIRE_DATABASE_NOT_BUSY(db->GetState());
		if (db->GetState()->backups == UCHAR_MAX) return ThrowRangeError("Too many active backups");

		UseIsolate;
		sqlite3* dest_handle;
		v8::String::Utf8Value dest_file(EXTRACT_STRING(isolate, destFile));
		v8::String::Utf8Value source_database(EXTRACT_STRING(isolate, sourceDatabase));
		int mask = (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);

		if (sqlite3_open_v2(*dest_file, &dest_handle, mask, NULL) != SQLITE_OK) {
			Database::ThrowBackupError(dest_handle);
			int status = sqlite3_close(dest_handle);
			assert(status == SQLITE_OK); ((void)status);
			return;
		}

		sqlite3_limit(dest_handle, SQLITE_LIMIT_LENGTH, INT_MAX);
		sqlite3_backup* backup_handle = sqlite3_backup_init(dest_handle, "main", db->GetHandle(), *source_database);
		if (backup_handle == NULL) {
			Database::ThrowBackupError(dest_handle);
			int status = sqlite3_close(dest_handle);
			assert(status == SQLITE_OK); ((void)status);
			return;
		}

		db->GetState()->backups += 1;
		Backup* backup = new Backup(db, dest_handle, backup_handle, pages);
		backup->Wrap(info.This());
		SetFrozen(isolate, OnlyContext, info.This(), CS::database, database);

		info.GetReturnValue().Set(info.This());
	}

	NODE_METHOD(JS_step) {
		Backup* backup = Unwrap<Backup>(info.This());
		if (!backup->alive) return ThrowTypeError("Backup operation was previously terminated");

		int status = sqlite3_backup_step(backup->backup_handle, backup->pages);
		if (status == SQLITE_OK || status == SQLITE_BUSY) {
			info.GetReturnValue().Set(v8::False(OnlyIsolate));
		} else {
			if (status == SQLITE_DONE) info.GetReturnValue().Set(v8::True(OnlyIsolate));
			else Database::ThrowBackupError(backup->dest_handle);
			backup->CloseHandles();
		}
	}

	void CloseHandles() {
		if (alive) {
			alive = false;
			sqlite3_backup_finish(backup_handle);
			int status = sqlite3_close(dest_handle);
			assert(status == SQLITE_OK); ((void)status);
			db->GetState()->backups -= 1;
		}
	}

	static v8::Persistent<v8::Function> constructor;
	static bool constructing_privileges;

	Database* const db;
	sqlite3* const dest_handle;
	sqlite3_backup* const backup_handle;
	const int pages;
	bool alive;
};
