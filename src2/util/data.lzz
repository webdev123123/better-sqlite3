#define JS_VALUE_TO_SQLITE(to, value, ...)                                     \
	if (value->IsNumber()) {                                                   \
		return sqlite3_##to##_double(__VA_ARGS__,                              \
			v8::Local<v8::Number>::Cast(value)->Value()                        \
		);                                                                     \
	} else if (value->IsString()) {                                            \
		v8::String::Utf8Value utf8(v8::Local<v8::String>::Cast(value));        \
		return sqlite3_##to##_text(__VA_ARGS__,                                \
			*utf8,                                                             \
			utf8.length(),                                                     \
			SQLITE_TRANSIENT                                                   \
		);                                                                     \
	} else if (value->IsNull() || value->IsUndefined()) {                      \
		return sqlite3_##to##_null(__VA_ARGS__);                               \
	} else if (node::Buffer::HasInstance(value)) {                             \
		return sqlite3_##to##_blob(__VA_ARGS__,                                \
			node::Buffer::Data(value),                                         \
			node::Buffer::Length(value),                                       \
			SQLITE_TRANSIENT                                                   \
		);                                                                     \
	} else if (Int64::HasInstance(value)) {                                    \
		return sqlite3_##to##_int64(__VA_ARGS__,                               \
			Unwrap<Int64>(v8::Local<v8::Object>::Cast(value))->GetValue()      \
		);                                                                     \
	}

#define SQLITE_VALUE_TO_JS(from, safe_integers, ...)                           \
	EasyIsolate;                                                               \
	int type = sqlite3_##from##_type(__VA_ARGS__);                             \
	switch (type) {                                                            \
	case SQLITE_INTEGER:                                                       \
		return Int64::NewProperInteger(                                        \
			isolate, sqlite3_##from##_int64(__VA_ARGS__), safe_integers        \
		);                                                                     \
	case SQLITE_FLOAT:                                                         \
		return v8::Number::New(isolate, sqlite3_##from##_double(__VA_ARGS__)); \
	case SQLITE_TEXT:                                                          \
		return StringFromUtf8(                                                 \
			isolate,                                                           \
			reinterpret_cast<const char*>(sqlite3_##from##_text(__VA_ARGS__)), \
			sqlite3_##from##_bytes(__VA_ARGS__)                                \
		);                                                                     \
	case SQLITE_BLOB:                                                          \
		return node::Buffer::Copy(                                             \
			isolate,                                                           \
			static_cast<const char*>(sqlite3_##from##_blob(__VA_ARGS__)),      \
			sqlite3_##from##_bytes(__VA_ARGS__)                                \
		).ToLocalChecked();                                                    \
	default: /* SQLITE_NULL */                                                 \
		return v8::Null(isolate);                                              \
	}                                                                          \
	assert(false);

namespace Data {
	
	v8::Local<v8::Value> GetValueJS(sqlite3_stmt* handle, int column, bool safe_integers) {
		SQLITE_VALUE_TO_JS(column, safe_integers, handle, column);
	}
	
	v8::Local<v8::Value> GetValueJS(sqlite3_value* value, bool safe_integers) {
		SQLITE_VALUE_TO_JS(value, safe_integers, value);
	}
	
	v8::Local<v8::Value> GetRowJS(sqlite3_stmt* handle, bool safe_integers) {
		EasyIsolate;
		v8::Local<v8::Context> ctx = isolate->GetCurrentContext();
		v8::Local<v8::Object> row = v8::Object::New(isolate);
		int column_count = sqlite3_column_count(handle);
		for (int i=0; i<column_count; ++i) {
			row->Set(ctx,
				InternalizedFromUtf8(isolate, sqlite3_column_name(handle, i), -1)
			, Data::GetValueJS(handle, i, safe_integers)).FromJust();
		}
		return row;
	}
	
	v8::Local<v8::Value>* GetArgumentsJS(sqlite3_value** values, int argument_count, bool safe_integers) {
		if (argument_count == 0) {
			return NULL;
		}
		v8::Local<v8::Value>* args = ALLOC_ARRAY(v8::Local<v8::Value>, argument_count);
		for (int i=0; i<argument_count; ++i) {
			args[i] = Data::GetValueJS(values[i], safe_integers);
		}
		return args;
	}
	
	int BindValueFromJS(sqlite3_stmt* handle, int index, v8::Local<v8::Value> value) {
		JS_VALUE_TO_SQLITE(bind, value, handle, index);
		return -1;
	}
	
	void ResultValueFromJS(sqlite3_context* ctx, v8::Local<v8::Value> value, Functor* error_action) {
		JS_VALUE_TO_SQLITE(result, value, ctx);
		error_action->Invoke(ctx);
	}
	
}
