class Transaction : public Nan::ObjectWrap, public Query {
public:
	
	// Provides public access to the constructor.
	static v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate, v8::Local<v8::Object> database, v8::Local<v8::Array> sources) {
		v8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, constructor);
		v8::Local<v8::Value> args[2] = { database, sources };
		constructing_privileges = true;
		v8::MaybeLocal<v8::Object> maybe_transaction = c->NewInstance(OnlyContext, 2, args);
		constructing_privileges = false;
		return maybe_transaction;
	}
	
	// Returns the Transaction's bind map (creates it upon first execution).
	BindMap* GetBindMap(v8::Isolate* isolate) {
		if (has_bind_map) return BindMapPointer();
		BindMap* bind_map = BindMapPointer();
		for (int h=0; h<handle_count; ++h) {
			sqlite3_stmt* handle = handles[h];
			int param_count = sqlite3_bind_parameter_count(handle);
			for (int i=1; i<=param_count; ++i) {
				const char* name = sqlite3_bind_parameter_name(handle, i);
				if (name != NULL) bind_map->Add(isolate, name + 1, i, h);
			}
		}
		has_bind_map = true;
		return bind_map;
	}
	
	// This should only be used by Database::CloseHandles() and ~Transaction().
	void CloseHandles() {
		if (alive) {
			alive = false;
			for (int i=0; i<handle_count; ++i) {
				if (bound) sqlite3_clear_bindings(handles[i]);
				sqlite3_finalize(handles[i]);
			}
			delete[] handles;
		}
	}
	
	~Transaction() {
		if (alive) db->RemoveTransaction(this);
		CloseHandles();
	}
	
private:
	
	explicit Transaction(Database* _db, TransactionHandles* _handles) : Nan::ObjectWrap(), Query(next_id++),
		db(_db),
		handles(_handles->handles),
		handle_count(_handles->handle_count),
		alive(true),
		bound(false),
		has_bind_map(false),
		safe_ints(_db->GetState()->safe_ints) {
		assert(db != NULL);
		assert(handles != NULL);
		assert(handle_count > 0);
		assert(handle_count <= BindMap::MAX_TRANSACTION_LENGTH);
		assert(db->GetState()->open);
		assert(!db->GetState()->busy);
		db->AddTransaction(this);
	}
	
	REGISTER(Init) {
		EasyIsolate;
		v8::Local<v8::FunctionTemplate> t = Nan::New<v8::FunctionTemplate>(JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(CS::Get(isolate, CS::Transaction));
		
		Nan::SetPrototypeMethod(t, "run", JS_run);
		Nan::SetPrototypeMethod(t, "bind", JS_bind);
		Nan::SetPrototypeMethod(t, "safeIntegers", JS_safeIntegers);
		// Nan::SetPrototypeMethod(t, CS::Get(isolate, CS::run), JS_run);
		// Nan::SetPrototypeMethod(t, CS::Get(isolate, CS::bind), JS_bind);
		// Nan::SetPrototypeMethod(t, CS::Get(isolate, CS::safeIntegers), JS_safeIntegers);
		
		constructor.Reset(isolate, Nan::GetFunction(t).ToLocalChecked());
		next_id = 0;
		constructing_privileges = false;
	}
	
	NODE_METHOD(JS_new) {
		if (!constructing_privileges) {
			return ThrowTypeError("Transactions can only be constructed by the db.transaction() method");
		}
		assert(info.IsConstructCall());
		REQUIRE_ARGUMENT_OBJECT(first, v8::Local<v8::Object> database);
		REQUIRE_ARGUMENT_ARRAY(second, v8::Local<v8::Array> sources);
		Database* db = Unwrap<Database>(database);
		REQUIRE_DATABASE_OPEN(db->GetState());
		REQUIRE_DATABASE_NOT_BUSY(db->GetState());
		REQUIRE_DATABASE_NOT_READONLY(db->GetState());
		uint32_t length = sources->Length();
		if (length == 0) {
			return ThrowRangeError("No SQL statements were provided");
		}
		if (length > BindMap::MAX_TRANSACTION_LENGTH) {
			return ThrowRangeError("Too many SQL statements were provided");
		}
		
		// UseIsolateAndContext;
		// SQLRope rope(static_cast<int>(length));
		// for (uint32_t i=0; i<length; ++i) {
		// 	v8::MaybeLocal<v8::Value> maybeValue = sources->Get(ctx, i);
		// 	if (maybeValue.IsEmpty()) {
		// 		return;
		// 	}
		// 	v8::Local<v8::Value> value = maybeValue.ToLocalChecked();
		// 	if (!value->IsString()) {
		// 		return ThrowTypeError("Expected each item in the given array to be a string");
		// 	}
		// 	rope.Push(v8::Local<v8::String>::Cast(value));
		// }
		
		// TransactionHandles handles(db->GetHandle(), &rope);
		// if (handles.had_error) {
		// 	return db->ThrowDatabaseError();
		// }
		
		Transaction* trans = new Transaction(db, &handles, db->GetState()->safe_ints);
		trans->Wrap(info.This());
		SetFrozen(isolate, ctx, info.This(), CS::source, rope->Concat(isolate));
		SetFrozen(isolate, ctx, info.This(), CS::database, database);
		
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_run) {} // TODO
	NODE_METHOD(JS_bind) {} // TODO
	NODE_METHOD(JS_safeIntegers) {} // TODO
	
	static v8::Persistent<v8::Function> constructor;
	static sqlite3_uint64 next_id;
	static bool constructing_privileges;
	
	Database* const db;
	sqlite3_stmt** const handles;
	const int handle_count;
	bool alive;
	bool bound;
	bool has_bind_map;
	bool safe_ints;
};
