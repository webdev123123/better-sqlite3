class Int64 : public Nan::ObjectWrap {
public:
	
	static inline v8::Local<v8::Value> NewProperInteger(v8::Isolate* isolate, sqlite3_int64 value, bool safe_integers) {
		if (safe_integers) {
			fast_construct_int = &value;
			return v8::Local<v8::Function>::New(isolate, constructor)->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();
		}
		return v8::Number::New(isolate, static_cast<double>(value));
	}
	
	static inline bool HasInstance(v8::Local<v8::Value> value) {
		EasyIsolate;
		return v8::Local<v8::FunctionTemplate>::New(isolate, constructorTemplate)->HasInstance(value);
	}
	
	inline sqlite3_int64 GetValue() {
		return full;
	}
	
private:
	explicit Int64(int32_t _low, int32_t _high) : Nan::ObjectWrap(),
		full((sqlite3_int64)((((sqlite3_uint64)((uint32_t)_high)) << 32) | (uint32_t)_low)),
		low(_low),
		high(_high) {
	}
	explicit Int64(sqlite3_int64 _full) : Nan::ObjectWrap(),
		full(_full),
		low((int32_t)((uint32_t)(((sqlite3_uint64)_full) & U32_in_U64))),
		high((int32_t)((uint32_t)(((sqlite3_uint64)_full) >> 32))) {
	}
	REGISTER(Init) {
		v8::Local<v8::FunctionTemplate> t = Nan::New<v8::FunctionTemplate>(JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(NEW_INTERNAL_STRING_FAST("Int64"));
		
		Nan::SetAccessor(t->InstanceTemplate(), NEW_INTERNAL_STRING_FAST("low"), JS_low);
		Nan::SetAccessor(t->InstanceTemplate(), NEW_INTERNAL_STRING_FAST("high"), JS_high);
		Nan::SetPrototypeMethod(t, "toString", JS_toString);
		Nan::SetPrototypeMethod(t, "valueOf", JS_valueOf);
		
		constructor.Reset(exports->GetIsolate(), Nan::GetFunction(t).ToLocalChecked());
		constructorTemplate.Reset(exports->GetIsolate(), t);
		fast_construct_int = NULL;
		
		Nan::Set(exports, NEW_INTERNAL_STRING_FAST("Int64"), Nan::GetFunction(t).ToLocalChecked());
	}
	NODE_METHOD(JS_new) {
		if (fast_construct_int != NULL) {
			Int64* int64 = new Int64(*fast_construct_int);
			fast_construct_int = NULL;
			int64->Wrap(info.This());
			return info.GetReturnValue().Set(info.This());
		}
		
		int32_t low;
		int32_t high;
		
		REQUIRE_ARGUMENT_INT32(first, low);
		if (info.Length() > 1) {
			REQUIRE_ARGUMENT_INT32(second, high);
		} else {
			high = 0;
		}
		
		Int64* int64 = new Int64(low, high);
		int64->Wrap(info.This());
		info.GetReturnValue().Set(info.This());
	}
	NODE_GETTER(JS_low) {
		info.GetReturnValue().Set(Unwrap<Int64>(info.This())->low);
	}
	NODE_GETTER(JS_high) {
		info.GetReturnValue().Set(Unwrap<Int64>(info.This())->high);
	}
	NODE_METHOD(JS_toString) {
		std::string string = std::to_string(static_cast<long long>(Unwrap<Int64>(info.This())->full));
		info.GetReturnValue().Set(StringFromLatin1(OnlyIsolate, string.c_str(), string.length()));
	}
	NODE_METHOD(JS_valueOf) {
		sqlite3_int64 full = Unwrap<Int64>(info.This())->full;
		if (full > MAX_SAFE || full < MIN_SAFE) {
			std::string string = std::to_string(static_cast<long long>(full));
			std::string message = CONCAT("Cannot losslessly convert ", string.c_str(), " to a number");
			return ThrowRangeError(message.c_str());
		}
		info.GetReturnValue().Set(static_cast<double>(full));
	}
	
	static const sqlite3_int64 MAX_SAFE = (sqlite3_int64)9007199254740991;
	static const sqlite3_int64 MIN_SAFE = (sqlite3_int64)-9007199254740991;
	static const sqlite3_uint64 U32_in_U64 = (sqlite3_uint64)0xffffffff;
	static v8::Persistent<v8::Function> constructor;
	static v8::Persistent<v8::FunctionTemplate> constructorTemplate;
	static sqlite3_int64* fast_construct_int;
	
	const sqlite3_int64 full;
	const int32_t low;
	const int32_t high;
};
