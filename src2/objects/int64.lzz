class Int64 : public Nan::ObjectWrap {
public:
	
	static inline v8::Local<v8::Value> NewProperInteger(v8::Isolate* isolate, sqlite3_int64 value, bool safe_integers) {
		if (safe_integers) {
			fast_construct_int = &value;
			return v8::Local<v8::Function>::New(isolate, constructor)->NewInstance(OnlyContext).ToLocalChecked();
		}
		return v8::Number::New(isolate, static_cast<double>(value));
	}
	
	static inline bool HasInstance(v8::Local<v8::Value> value) {
		EasyIsolate;
		return v8::Local<v8::FunctionTemplate>::New(isolate, constructorTemplate)->HasInstance(value);
	}
	
	inline sqlite3_int64 GetValue() {
		return value;
	}
	
private:
	explicit Int64(int32_t low, int32_t high) : Nan::ObjectWrap(),
		value((sqlite3_int64)((((sqlite3_uint64)((uint32_t)high)) << 32) | (uint32_t)low)) {
	}
	explicit Int64(sqlite3_int64 _value) : Nan::ObjectWrap(),
		value(_value) {
	}
	REGISTER(Init) {
		EasyIsolate;
		v8::Local<v8::FunctionTemplate> t = Nan::New<v8::FunctionTemplate>(JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(CS::Get(isolate, CS::Int64));
		
		Nan::SetAccessor(t->InstanceTemplate(), CS::Get(isolate, CS::low), JS_low);
		Nan::SetAccessor(t->InstanceTemplate(), CS::Get(isolate, CS::high), JS_high);
		Nan::SetPrototypeMethod(t, "toString", JS_toString);
		Nan::SetPrototypeMethod(t, "valueOf", JS_valueOf);
		// Nan::SetPrototypeMethod(t, CS::Get(isolate, CS::toString), JS_toString);
		// Nan::SetPrototypeMethod(t, CS::Get(isolate, CS::valueOf), JS_valueOf);
		
		constructor.Reset(exports->GetIsolate(), Nan::GetFunction(t).ToLocalChecked());
		constructorTemplate.Reset(exports->GetIsolate(), t);
		fast_construct_int = NULL;
		
		Nan::Set(exports, CS::Get(isolate, CS::Int64), Nan::GetFunction(t).ToLocalChecked());
	}
	NODE_METHOD(JS_new) {
		if (fast_construct_int != NULL) {
			Int64* int64 = new Int64(*fast_construct_int);
			fast_construct_int = NULL;
			int64->Wrap(info.This());
			return info.GetReturnValue().Set(info.This());
		}
		
		int32_t low;
		int32_t high;
		
		REQUIRE_ARGUMENT_INT32(first, low);
		if (info.Length() > 1) {
			REQUIRE_ARGUMENT_INT32(second, high);
		} else {
			high = 0;
		}
		
		Int64* int64 = new Int64(low, high);
		int64->Wrap(info.This());
		info.GetReturnValue().Set(info.This());
	}
	NODE_GETTER(JS_low) {
		sqlite3_int64 value = Unwrap<Int64>(info.This())->value;
		info.GetReturnValue().Set((int32_t)((uint32_t)(((sqlite3_uint64)value) & U32_in_U64)));
	}
	NODE_GETTER(JS_high) {
		sqlite3_int64 value = Unwrap<Int64>(info.This())->value;
		info.GetReturnValue().Set((int32_t)((uint32_t)(((sqlite3_uint64)value) >> 32)));
	}
	NODE_METHOD(JS_toString) {
		std::string string = std::to_string(static_cast<long long>(Unwrap<Int64>(info.This())->value));
		info.GetReturnValue().Set(StringFromLatin1(OnlyIsolate, string.c_str(), string.length()));
	}
	NODE_METHOD(JS_valueOf) {
		sqlite3_int64 value = Unwrap<Int64>(info.This())->value;
		if (value > MAX_SAFE || value < MIN_SAFE) {
			std::string string = std::to_string(static_cast<long long>(value));
			std::string message = CONCAT("Cannot losslessly convert ", string.c_str(), " to a number");
			return ThrowRangeError(message.c_str());
		}
		info.GetReturnValue().Set(static_cast<double>(value));
	}
	
	static const sqlite3_int64 MAX_SAFE = (sqlite3_int64)9007199254740991;
	static const sqlite3_int64 MIN_SAFE = (sqlite3_int64)-9007199254740991;
	static const sqlite3_uint64 U32_in_U64 = (sqlite3_uint64)0xffffffff;
	static v8::Persistent<v8::Function> constructor;
	static v8::Persistent<v8::FunctionTemplate> constructorTemplate;
	static sqlite3_int64* fast_construct_int;
	
	const sqlite3_int64 value;
};
