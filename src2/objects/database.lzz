class Database : public Nan::ObjectWrap {
private:
	
	class DatabaseExtras { friend class Database;
		explicit DatabaseExtras(DatabaseHandles* handles)
			: stmts(), transs(), begin(handles->begin), commit(handles->commit), rollback(handles->rollback) {
			assert(handles->error == NULL);
		}
		std::set<Statement*, Query::Compare> stmts;
		std::set<Transaction*, Query::Compare> transs;
		sqlite3_stmt* const begin;
		sqlite3_stmt* const commit;
		sqlite3_stmt* const rollback;
	};
	
	explicit Database(DatabaseHandles* handles, bool _readonly) : Nan::ObjectWrap(),
		db_handle(handles->db_handle),
		extras(handles),
		open(true),
		busy(false),
		pragma_mode(false),
		safe_ints(false),
		was_js_error(false),
		readonly(_readonly) {
		assert(handles->error == NULL);
	}
	
	~Database() {
		// CloseChildHandles();
		// CloseHandles();
		// delete extras;
	}
	
	REGISTER(Init) {
		v8::Local<v8::FunctionTemplate> t = Nan::New<v8::FunctionTemplate>(JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(NEW_INTERNAL_STRING_FAST("Database"));
		
		Nan::SetPrototypeMethod(t, "prepare", JS_prepare);
		Nan::SetPrototypeMethod(t, "transaction", JS_transaction);
		Nan::SetPrototypeMethod(t, "exec", JS_exec);
		Nan::SetPrototypeMethod(t, "pragma", JS_pragma);
		Nan::SetPrototypeMethod(t, "checkpoint", JS_checkpoint);
		Nan::SetPrototypeMethod(t, "register", JS_register);
		Nan::SetPrototypeMethod(t, "close", JS_close);
		Nan::SetPrototypeMethod(t, "defaultSafeIntegers", JS_defaultSafeIntegers);
		Nan::SetAccessor(t->InstanceTemplate(), NEW_INTERNAL_STRING_FAST("open"), JS_open);
		
		Nan::Set(exports, NEW_INTERNAL_STRING_FAST("Database"), Nan::GetFunction(t).ToLocalChecked());
	}
	
	NODE_METHOD(JS_new) {
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> filename);
		REQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> filenameGiven);
		REQUIRE_ARGUMENT_BOOLEAN(third, bool in_memory);
		REQUIRE_ARGUMENT_BOOLEAN(fourth, bool readonly);
		UseIsolate;
		UseContext;
		
		DatabaseHandles handles(filename);
		if (handles.error) {
			CONCAT2(message, "SQLite: ", handles.error);
			return ThrowError(message.c_str());
		}
		
		assert(sqlite3_db_mutex(handles.db_handle) == NULL);
		sqlite3_busy_timeout(handles.db_handle, 5000);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_LENGTH, MAX_BUFFER_SIZE < MAX_STRING_SIZE ? MAX_BUFFER_SIZE : MAX_STRING_SIZE);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_SQL_LENGTH, MAX_STRING_SIZE);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_COLUMN, INT_MAX);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_COMPOUND_SELECT, INT_MAX);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_VARIABLE_NUMBER, BindMap::PARAMETER_MASK);
		
		Database* db = new Database(&handles, readonly);
		db->Wrap(info.This());
		info.This()->DefineOwnProperty(ctx, NEW_INTERNAL_STRING_FAST("memory"), in_memory ? v8::True(isolate) : v8::False(isolate), FROZEN).FromJust();
		info.This()->DefineOwnProperty(ctx, NEW_INTERNAL_STRING_FAST("readonly"), readonly ? v8::True(isolate) : v8::False(isolate), FROZEN).FromJust();
		info.This()->DefineOwnProperty(ctx, NEW_INTERNAL_STRING_FAST("name"), filenameGiven, FROZEN).FromJust();
		
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_prepare) {
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> source);
		v8::MaybeLocal<v8::Object> maybe_statement = Statement::New(Unwrap<Database>(info.This()), OnlyIsolate, source);
		if (!maybe_statement.IsEmpty()) {
			info.GetReturnValue().Set(maybe_statement.ToLocalChecked());
		}
	}
	
	NODE_METHOD(JS_transaction) {
		REQUIRE_ARGUMENT_ARRAY(first, v8::Local<v8::Array> sources);
		v8::MaybeLocal<v8::Object> maybe_transaction = Transaction::New(Unwrap<Database>(info.This()), OnlyIsolate, sources);
		if (!maybe_transaction.IsEmpty()) {
			info.GetReturnValue().Set(maybe_transaction.ToLocalChecked());
		}
	}
	
	NODE_METHOD(JS_exec) {
		Database* db = Unwrap<Database>(info.This());
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> source);
		REQUIRE_DATABASE_OPEN(db);
		REQUIRE_DATABASE_NOT_BUSY(db);
		REQUIRE_DATABASE_NOT_READONLY(db);
		
		v8::String::Utf8Value sql(source);
		char* err;
		
		sqlite3_exec(db->db_handle, *sql, NULL, NULL, &err);
		if (err != NULL) {
			db->ThrowDatabaseError(err);
			return sqlite3_free(err);
		}
		
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_pragma) {
		REQUIRE_ARGUMENT_BOOLEAN(first, bool state);
		Unwrap<Database>(info.This())->pragma_mode = state;
	}
	
	NODE_METHOD(JS_checkpoint) {
		Database* db = Unwrap<Database>(info.This());
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> onlyDatabase);
		REQUIRE_ARGUMENT_BOOLEAN(second, bool force);
		REQUIRE_DATABASE_OPEN(db);
		REQUIRE_DATABASE_NOT_BUSY(db);
		REQUIRE_DATABASE_NOT_READONLY(db);
		static auto get_ratio = [](int tf, int cf) {
			return (cf < 0 || tf <= 0) ? 1.0 : (static_cast<double>(cf) / static_cast<double>(tf));
		}
		
		UseIsolate;
		v8::String::Utf8Value only_database(onlyDatabase);
		int mode = force ? SQLITE_CHECKPOINT_RESTART : SQLITE_CHECKPOINT_PASSIVE;
		int total_frames;
		int checkpointed_frames;
		
		if (only_database.length() != 0) {
			int status = sqlite3_wal_checkpoint_v2(db->db_handle, *only_database, mode, &total_frames, &checkpointed_frames);
			if (status == SQLITE_OK) return info.GetReturnValue().Set(v8::Number::New(isolate, get_ratio(total_frames, checkpointed_frames)));
			if (status == SQLITE_BUSY) return info.GetReturnValue().Set(v8::Number::New(isolate, 0.0));
			return db->ThrowDatabaseError();
		}
		
		sqlite3_stmt* st_handle;
		if (sqlite3_prepare_v2(db->db_handle, "PRAGMA database_list", -1, &st_handle, NULL) != SQLITE_OK) {
			return db->ThrowDatabaseError();
		}
		std::vector<std::string> database_names;
		while (sqlite3_step(st_handle) == SQLITE_ROW) {
			database_names.emplace_back(reinterpret_cast<const char*>(sqlite3_column_text(st_handle, 1)), sqlite3_column_bytes(st_handle, 1));
		}
		if (sqlite3_finalize(st_handle) != SQLITE_OK) {
			return db->ThrowDatabaseError();
		}
		
		UseContext;
		v8::Local<v8::Object> result = v8::Object::New(isolate);
		for (std::string const &name : database_names) {
			int status = sqlite3_wal_checkpoint_v2(db->db_handle, name.c_str(), mode, &total_frames, &checkpointed_frames);
			if (status == SQLITE_OK) {
				result->Set(ctx, InternalizedFromUtf8(name.c_str()), v8::Number::New(isolate, get_ratio(total_frames, checkpointed_frames)));
			} else if (status == SQLITE_BUSY) {
				result->Set(ctx, InternalizedFromUtf8(name.c_str()), v8::Number::New(isolate, 0.0));
			} else {
				return db->ThrowDatabaseError();
			}
		}
		info.GetReturnValue().Set(result);
	}
	
	static const int MAX_BUFFER_SIZE = node::Buffer::kMaxLength > INT_MAX ? INT_MAX : static_cast<int>(node::Buffer::kMaxLength);
	static const int MAX_STRING_SIZE = v8::String::kMaxLength > INT_MAX ? INT_MAX : static_cast<int>(v8::String::kMaxLength);
	static const v8::PropertyAttribute FROZEN = static_cast<v8::PropertyAttribute>(v8::DontDelete | v8::ReadOnly);
	static sqlite3_uint64 next_statement_id = 0;
	static sqlite3_uint64 next_transaction_id = 0;
	
	NODE_GETTER(JS_open);
	NODE_METHOD(JS_close);
	NODE_METHOD(JS_register);
	NODE_METHOD(JS_defaultSafeIntegers);
	
	static bool CONSTRUCTING_PRIVILEGES;
	
	static void ExecuteFunction(sqlite3_context*, int, sqlite3_value**);
	static void StepAggregate(sqlite3_context*, int, sqlite3_value**);
	static void FinishAggregate(sqlite3_context*);
	
	int OpenHandles(const char*); // If SQLITE_OK is not returned, CloseHandles should be invoked
	int CloseHandles();
	void CloseChildHandles();
	void ThrowDatabaseError(const char* = NULL);
	
	sqlite3* const db_handle;
	DatabaseExtras* const extras;
	
	// State
	bool open;
	bool busy;
	bool pragma_mode;
	bool safe_ints;
	bool was_js_error;
	const bool readonly;
};
