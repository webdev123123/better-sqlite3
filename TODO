TODO SHORTLIST

review statement reset policy (write statements dont commit until reset?)
investigate BEGIN IMMEDIATE as an alternative to mutexes
transaction concurrency
better transaction destruction/CloseHandles

--------------------------------------------------------------------------------

in c++:

Two JavaScript APIs:
- begin()
This returns a Transaction object. You can use .and() to append statements into the transaction. These statements may be read-only, or not. When finished adding statements, you must use .end() or .commit(), after which the transaction can be .run() (possibly multiple times). The .run() method returns a promise, which resolves with an object describing the changes, or rejects with an Error.





startTransaction() API does:
is the active_tranaction flag set? -> push to the db connection's transaction queue
otherwise -> set active_tranaction flag to 1, and exec "BEGIN;"



endTransaction() API does:
-> set active_tranaction flag to 2, and exec "COMMIT;"
-> flush up to, but not including, the next transaction



when statement is about to be executed:
is the active_tranaction flag 0 or 1? -> execute it
otherwise -> push it to the transaction queue, which is associated with the database connection



on commit hook AND on rollback hook:
if there is something in the db connection's queue -> flush up to, and including, the next transaction
otherwise -> set active_tranaction flag to 0



---------- Polish ----------
optmize DB_LOCK/DB_UNLOCK by making them only surround from sqlite3_step to error check
Maybe dont lock readers, for better performance? Remember that locks also occur in the
GET_COLUMN_COUNT macro. Also, implement transaction thread concurrency (like NewHandle()),
and maybe even transaction handle caching.

use SQLITE_ENABLE_API_ARMOR compilation option while developing

Polish the changes/last_row_id API of .run()

reduce the number of memory copies:
- when binding strings, I can use SQLITE_TRANSIENT if I make the string temporarily persistent
- when binding blobs, I can do the same thing as above, as long as I'm not scared of the user changing the buffer's underlying memory mid-execution
- use ExternalStringResource and sqlite3_column_text16 and sqlite3_column_bytes16 to prevent a copying of data in Data::Text (similar to Data::Blob)

optimize binding by creating bind maps when statements and transactions are
created. This way, we can eliminate overhead caused by the NextAnonIndex()
and GetNamedParameterIndex() functions

we could use ExternalStringResource to make trans->source only exist in one place, to reduce memory consumption of Statement objects

if we promisify run(), get(), all(), or each(), their performance will suffer
if more than 3 arguments are passed (more than 2 bound arguments for each())

---------- Automatic Atomic Transactions ----------
on commit hook, check for error, and if there was an error, return 1
the commit will then be converted into a rollback


---------- Package ----------
deal with ./test/ and .travis.yml


---------- Executable ----------
all tables should have INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL

in order for foreign keys to be unconditionally enforced, the child column must have NOT NULL

null values count as unique from eachother for UNIQUE constraints (and basically everything else)

DEFAULT applies when no value is specified for an INSERT. Explicitly given nulls do not trigger DEFAULT

foreign key REFERENCES <table> can be followed by ON DELETE and/or ON UPDATE:
SET NULL = when the parent's column is updated or deleted, the child's column becomes null
           (this still causes a violation if the child has NOT NULL)
SET DEFAULT = when the parent's column is updated or deleted, the child's column becomes the DEFAULT
              (this still causes a violation if the DEFAULT does not correspond with an actual parent)
CASCADE = when the parent row is deleted, the child row is deleted
          (for updates, the value propogates to all children)

ALTER TABLE actions

DROP TABLE actions
